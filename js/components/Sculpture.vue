
<template>
</template>

<script>



import {Sculpture} from '../SculptureN.js';
import * as THREE from 'three';
import { defaultFragSourceJS, defaultFragSourceGLSL } from '../default-shader.js'
import {mapGetters} from 'vuex';
import {sourceGenerator} from '../jsapi/generate.js';

function defaultMap(obj, id, def) {
    if(obj && obj[id]) {
        return obj[id];
    } else {
        return def;
    }
}
export default {
    props: ['sculpData', 'sculpGeom'],
    data: function() {
        return {
            //This all gets saved to the Database!!!!
            id : this.sculpData.id || this._uid,
            vueId: this._uid,
            uid : this.sculpData.uid || null,
            username : this.sculpData.username || null,
            title : this.sculpData.title || null,
            isExample: this.sculpData.isExample || false,
            description : this.sculpData.description || null,
            tags : this.sculpData.tags || null,
            timestamp : this.sculpData.timestamp || Date.now(),
            favorites : this.sculpData.favorites || 0,
            views: this.sculpData.views || 0,
            comments : this.sculpData.comments || 0,
            forks : this.sculpData.forks || 0,
            fork : this.sculpData.fork || null, //if a fork set to id
            featured : this.sculpData.featured || false,
            visibility : this.sculpData.visibility || 'public', //draft, public, private
            license : this.sculpData.license || null, 
            shaderSource: this.sculpData.shaderSource || ((this.sculpData.type && this.sculpData.type === 'glsl')? defaultFragSourceGLSL: defaultFragSourceJS),
            type: this.sculpData.type || 'js',
            saved : this.sculpData.shaderSource? true: false,
            //sculpture is not saved to the db
            sculpture: this.sculpGeom || null
        };
    },
    mounted() {
        // this.$data = Object.assign(this.$data, this.sculpData);
        console.log('mounted sculp');
        let shadeSource = this.shaderSource.slice();
        if(this.type === 'js') {
                let source = sourceGenerator(this.shaderSource);
                let glsl = source.geoGLSL + source.colorGLSL;
                shadeSource = glsl;
                if(!this.sculpture) {
                    this.sculpture = new Sculpture(glsl);
                } else {
                    this.sculpture.setShaderSource(glsl);
                    //TODO THIS MIGHT BE Very large added computation
                    this.sculpture.refreshMaterial();
                }
        } else if(!this.sculpture) {
            this.sculpture = new Sculpture(this.shaderSource);
        }
        
        if(this.id) {
            this.sculpture.mesh.name = this.id;
        } else {
            this.sculpture.mesh.name = this._uid; //_uid is a unique ID generated by vue for a component
        }
        this.$store.state.scene.add(this.sculpture.mesh);
        this.$store.state.objectsToUpdate.push(this.sculpture);
        this.$store.state.objectsToRaycast.push(this.sculpture.mesh);
        if(this.$store.state.selectedObject) {
            this.setSelectedSculpture(this.$store.state.selectedObject);
        }
        
        // console.log('this.$data');
        // console.log(this.$data);
        // console.log(this.$store.state.scene);

        // let grid = {x: 1, z: 1, spacing: 4.0, size: 1.0, ceiling: 2.0};
        // let scene = this.$store.state.scene;
        // scene.remove(scene.getObjectByName('hl-boxes'));
        // scene.remove(scene.getObjectByName('sculptures'));

        // scene.add(create_hl_box(grid));
        // scene.add(create_sculps(grid, [], this.$store.state.socket));
    },
    watch: {
        shaderSource: function (val) {
            console.log('setting shader source', val);
            if(this.sculpture) {
                this.shaderSource = val;
                if(this.type === 'js') {
                    let source = sourceGenerator(val);
                    let glsl = source.geoGLSL + source.colorGLSL;
                    this.sculpture.setShaderSource(glsl);
                } else {
                    this.sculpture.setShaderSource(val);
                }
                this.sculpture.refreshMaterial();
            }
        },
        selectedObject: function (obj) {
            this.setSelectedSculpture(obj);
        },
        id: function (val) {
            console.log('id of sculp changed to' + val);
        }
    },
    computed: {
        currUserID () {
            return this.$store.getters.getUser.uid
        },
        selectedObject() {
            return this.$store.state.selectedObject;
        }
    },
    methods: {
        setPose(pose){
            // this.sculpture.mesh.
        },
        setSaved(saved) {
            this.saved = saved;
        },
        setSelectedSculpture(obj) {
            if(obj && obj.name == this.sculpture.mesh.name) {
                console.log('selected!!', this.$data);
                this.$store.state.selectedSculpture = this.$data;
                this.sculpture.selectedSculpture(true);
            } else {
                if(this.sculpture.selected) {
                    this.sculpture.selectedSculpture(false);
                }
            }
        },
        removeSculpture() {
            const name = this.id || this._uid;
            this.$store.commit('removeObjectFromUpdate', this.sculpture);
            this.$store.commit('removeObjectFromRaycast', this.sculpture.mesh);
            this.$store.commit('removeObjectFromSceneByName', name);
        }
    },
    destroyed: function() {
        this.removeSculpture();
        // console.log(`deleted ${name} from scene`);
    }
};
</script>