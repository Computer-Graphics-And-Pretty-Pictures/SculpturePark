
<template>
</template>

<script>



import {Sculpture} from '../SculptureN.js';
import * as THREE from 'three';
import {mapGetters} from 'vuex';
import {defaultFragSourceJS, defaultFragSourceGLSL, sourceGenerator} from 'sculpture-park-core';

function defaultMap(obj, id, def) {
    if(obj && obj[id]) {
        return obj[id];
    } else {
        return def;
    }
}
export default {
    props: ['sculpData', 'sculpPosition'],
    data: function() {
        return {
            //This all gets saved to the Database!!!!
            id : this.sculpData.id || this._uid,
            vueId: this._uid,
            uid : this.sculpData.uid || null,
            username : this.sculpData.username || null,
            title : this.sculpData.title || null,
            isExample: this.sculpData.isExample || false,
            description : this.sculpData.description || null,
            tags : this.sculpData.tags || null,
            timestamp : this.sculpData.timestamp || Date.now(),
            favorites : this.sculpData.favorites || 0,
            views: this.sculpData.views || 0,
            comments : this.sculpData.comments || 0,
            forks : this.sculpData.forks || 0,
            fork : this.sculpData.fork || null, //if a fork set to id
            featured : this.sculpData.featured || false,
            visibility : this.sculpData.visibility || 'public', //draft, public, private
            license : this.sculpData.license || null, 
            shaderSource: this.sculpData.shaderSource || ((this.sculpData.type && this.sculpData.type === 'glsl')? defaultFragSourceGLSL: defaultFragSourceJS),
            type: this.sculpData.type || 'js',
            saved : this.sculpData.shaderSource? true: false,
            //sculpture is not saved to the db
            sculpture: null
        };
    },
    mounted() {
        // this.$data = Object.assign(this.$data, this.sculpData);
        let shadeSource = this.shaderSource.slice();
        
        if(this.type === 'js') {
            shadeSource = this.generateJSSource(this.shaderSource);
                // let source = sourceGenerator(this.shaderSource);
                
                // let glsl = source.geoGLSL + source.colorGLSL;
                // shadeSource = glsl;
                // this.uniforms = source.uniforms;
        }
        this.sculpture = new Sculpture(shadeSource, this.MSDFTexture, this.uniforms);
        
        if(this.sculpPosition) {
            this.setPose(this.sculpPosition);
        }
        if(this.id) {
            this.sculpture.mesh.name = this.id;
        } else {
            this.sculpture.mesh.name = this._uid; //_uid is a unique ID generated by vue for a component
        }
        this.$store.state.scene.add(this.sculpture.mesh);
        this.$store.state.objectsToUpdate.push(this.sculpture);
        this.$store.state.objectsToRaycast.push(this.sculpture.mesh);
        if(this.$store.state.selectedObject) {
            this.setSelectedSculpture(this.$store.state.selectedObject);
        }
    },
    watch: {
        shaderSource: function (input) {
            if(this.sculpture) {
                this.shaderSource = input;
                if(this.type === 'js') {
                    let glsl = this.generateJSSource(input);
                    this.sculpture.setShaderSource(glsl);
                } else {
                    this.sculpture.setShaderSource(input);
                }
                this.sculpture.refreshMaterial(this.uniforms);
            }
        },
        selectedObject: function (obj) {
            this.setSelectedSculpture(obj);
        },
        id: function (val) {
            console.log('id of sculp changed to' + val);
        }
    },
    computed: {
        currUserID () {
            return this.$store.getters.getUser.uid
        },
        selectedObject() {
            return this.$store.state.selectedObject;
        },
        MSDFTexture () {
            return this.$store.getters.getMSDFTexture;
        },
    },
    methods: {
        generateJSSource(input) {
            let source = sourceGenerator(input);
            if(source.error) {
                console.error(source.error);
            }
            let glsl = source.geoGLSL + source.colorGLSL;
            this.uniforms = source.uniforms;
            return glsl;
        },
        setPose(pose) {
            this.sculpture.mesh.position = this.sculpPosition;
        },
        setSaved(saved) {
            this.saved = saved;
        },
        setSelectedSculpture(obj) {
            if(obj && obj.name == this.sculpture.mesh.name) {
                this.$store.state.selectedSculpture = this.$data;
                this.sculpture.selectedSculpture(true);
            } else {
                if(this.sculpture.selected) {
                    this.sculpture.selectedSculpture(false);
                }
            }
        },
        removeSculpture() {
            const name = this.id || this._uid;
            this.$store.commit('removeObjectFromUpdate', this.sculpture);
            this.$store.commit('removeObjectFromRaycast', this.sculpture.mesh);
            this.$store.commit('removeObjectFromSceneByName', name);
        }
    },
    destroyed: function() {
        this.removeSculpture();
        // console.log(`deleted ${name} from scene`);
    }
};
</script>